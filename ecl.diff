diff --git a/EKF/control.cpp b/EKF/control.cpp
index 528391b..d9754b8 100644
--- a/EKF/control.cpp
+++ b/EKF/control.cpp
@@ -241,46 +241,47 @@ void Ekf::controlExternalVisionFusion()
 
 			// Use an incremental position fusion method for EV position data if GPS is also used
 			if (_params.fusion_mode & MASK_USE_GPS) {
+			//if (_params.fusion_mode & _control_status.flags.gps) {
 				_fuse_hpos_as_odom = true;
 			} else {
 				_fuse_hpos_as_odom = false;
 			}
 
+			Vector3f ev_pos_meas = _ev_sample_delayed.pos;
+			Matrix3f ev_pos_var = matrix::diag(_ev_sample_delayed.posVar);
+			if (_params.fusion_mode & MASK_ROTATE_EV) {
+				ev_pos_meas = _R_ev_to_ekf * ev_pos_meas;
+				ev_pos_var = _R_ev_to_ekf * ev_pos_var * _R_ev_to_ekf.transpose();
+			}
+
 			if (_fuse_hpos_as_odom) {
 				if (!_hpos_prev_available) {
 					// no previous observation available to calculate position change
+				        // record observation and estimate for use next time
 					_hpos_prev_available = true;
+					_ev_delta_pos = _state.pos -  ev_pos_meas;
 
 				} else {
 					// calculate the change in position since the last measurement
-					Vector3f ev_delta_pos = _ev_sample_delayed.pos - _pos_meas_prev;
-
-					// rotate measurement into body frame is required when fusing with GPS
-					ev_delta_pos = _R_ev_to_ekf * ev_delta_pos;
+					//ev_delta_pos = _hpos_pred_prev - _pos_meas_prev;
 
 					// use the change in position since the last measurement
-					_ev_pos_innov(0) = _state.pos(0) - _hpos_pred_prev(0) - ev_delta_pos(0);
-					_ev_pos_innov(1) = _state.pos(1) - _hpos_pred_prev(1) - ev_delta_pos(1);
+					_ev_pos_innov(0) = _state.pos(0) - ev_pos_meas(0) - _ev_delta_pos(0);
+					_ev_pos_innov(1) = _state.pos(1) - ev_pos_meas(1) - _ev_delta_pos(1);
 
 					// observation 1-STD error, incremental pos observation is expected to have more uncertainty
-					Matrix3f ev_pos_var = matrix::diag(_ev_sample_delayed.posVar);
-					ev_pos_var = _R_ev_to_ekf * ev_pos_var * _R_ev_to_ekf.transpose();
 					ev_pos_obs_var(0) = fmaxf(ev_pos_var(0, 0), sq(0.5f));
 					ev_pos_obs_var(1) = fmaxf(ev_pos_var(1, 1), sq(0.5f));
-				}
+					
+			// innovation gate size
+			ev_pos_innov_gates(0) = fmaxf(_params.ev_pos_innov_gate, 1.0f);
 
-				// record observation and estimate for use next time
-				_pos_meas_prev = _ev_sample_delayed.pos;
-				_hpos_pred_prev = _state.pos.xy();
+			fuseHorizontalPosition(_ev_pos_innov, ev_pos_innov_gates, ev_pos_obs_var, _ev_pos_innov_var, _ev_pos_test_ratio);
+				        // record observation and estimate for use next time
+					//_ev_delta_pos = _state.pos - ev_pos_meas;
+				}
 
 			} else {
-				// use the absolute position
-				Vector3f ev_pos_meas = _ev_sample_delayed.pos;
-				Matrix3f ev_pos_var = matrix::diag(_ev_sample_delayed.posVar);
-				if (_params.fusion_mode & MASK_ROTATE_EV) {
-					ev_pos_meas = _R_ev_to_ekf * ev_pos_meas;
-					ev_pos_var = _R_ev_to_ekf * ev_pos_var * _R_ev_to_ekf.transpose();
-				}
 				_ev_pos_innov(0) = _state.pos(0) - ev_pos_meas(0);
 				_ev_pos_innov(1) = _state.pos(1) - ev_pos_meas(1);
 
@@ -297,12 +298,12 @@ void Ekf::controlExternalVisionFusion()
 
 					resetHorizontalPosition();
 				}
-			}
-
 			// innovation gate size
 			ev_pos_innov_gates(0) = fmaxf(_params.ev_pos_innov_gate, 1.0f);
 
 			fuseHorizontalPosition(_ev_pos_innov, ev_pos_innov_gates, ev_pos_obs_var, _ev_pos_innov_var, _ev_pos_test_ratio);
+			}
+
 		}
 
 		// determine if we should use the velocity observations
diff --git a/EKF/ekf.h b/EKF/ekf.h
index 1f08c14..5d40378 100644
--- a/EKF/ekf.h
+++ b/EKF/ekf.h
@@ -337,8 +337,9 @@ private:
 
 	// variables used when position data is being fused using a relative position odometry model
 	bool _fuse_hpos_as_odom{false};		///< true when the NE position data is being fused using an odometry assumption
-	Vector3f _pos_meas_prev;		///< previous value of NED position measurement fused using odometry assumption (m)
-	Vector2f _hpos_pred_prev;		///< previous value of NE position state used by odometry fusion (m)
+	//Vector3f _pos_meas_prev;		///< previous value of NED position measurement fused using odometry assumption (m)
+	//Vector2f _hpos_pred_prev;		///< previous value of NE position state used by odometry fusion (m)
+	Vector3f _ev_delta_pos;		///< previous value of NE position state used by odometry fusion (m)
 	bool _hpos_prev_available{false};	///< true when previous values of the estimate and measurement are available for use
 	Dcmf _R_ev_to_ekf;			///< transformation matrix that rotates observations from the EV to the EKF navigation frame, initialized with Identity
 	bool _inhibit_ev_yaw_use{false};	///< true when the vision yaw data should not be used (e.g.: NE fusion requires true North)
